# -*- coding: utf-8 -*-
"""speared.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-_s-DdcNGs441zq1ScoLpO3YHYS8Pdv9
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt
import seaborn as sns
import folium
from datetime import datetime

df = pd.read_csv(r"D:\Excel\MODIS_C6_1_Global_24h.csv")
df.head()
df.info()

"""pre processing"""

df['datetime'] = pd.to_datetime(
    df['acq_date'] + ' ' + df['acq_time'].astype(str).str.zfill(4),
    format='%Y-%m-%d %H%M'
)

df.drop(columns=['scan', 'track', 'version', 'acq_date', 'acq_time'], inplace=True)

df['satellite'] = df['satellite'].astype('category').cat.codes
df['daynight'] = df['daynight'].astype('category').cat.codes

scaler = MinMaxScaler()
scale_cols = ['brightness', 'bright_t31', 'frp', 'confidence']
df[scale_cols] = scaler.fit_transform(df[scale_cols])

df['hour'] = df['datetime'].dt.hour
df['day'] = df['datetime'].dt.day
df['month'] = df['datetime'].dt.month

df.head()

sns.scatterplot(x='longitude', y='latitude', hue='confidence', data=df, palette='coolwarm')
plt.title("Fire Detections (Color: Confidence)")
plt.show()

m = folium.Map(location=[df.latitude.mean(), df.longitude.mean()], zoom_start=5)
for i, row in df.iterrows():
    folium.CircleMarker(
        location=[row['latitude'], row['longitude']],
        radius=2,
        popup=f"Confidence: {row['confidence']}",
        color='red' if row['daynight'] == 1 else 'orange',
        fill=True,
    ).add_to(m)
m

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation

# Define grid size (you can adjust this)
GRID_SIZE = 100

# Create an empty grid (0 = no fire, 1 = fire, 2 = burned)
grid = np.zeros((GRID_SIZE, GRID_SIZE), dtype=int)

# Normalize lat-lon to grid coordinates
lat_min, lat_max = df['latitude'].min(), df['latitude'].max()
lon_min, lon_max = df['longitude'].min(), df['longitude'].max()

def latlon_to_grid(lat, lon):
    x = int((lat - lat_min) / (lat_max - lat_min) * (GRID_SIZE - 1))
    y = int((lon - lon_min) / (lon_max - lon_min) * (GRID_SIZE - 1))
    return x, y

# Initialize fire locations from dataset
for _, row in df.iterrows():
    x, y = latlon_to_grid(row['latitude'], row['longitude'])
    grid[x, y] = 1  # Set fire

def update_fire(grid):
    new_grid = grid.copy()
    for i in range(1, GRID_SIZE-1):
        for j in range(1, GRID_SIZE-1):
            if grid[i, j] == 1:  # currently on fire
                # Try to spread to neighbors
                for dx in [-1, 0, 1]:
                    for dy in [-1, 0, 1]:
                        if grid[i+dx, j+dy] == 0:
                            if np.random.rand() < 0.3:  # probability of spread
                                new_grid[i+dx, j+dy] = 1
                new_grid[i, j] = 2  # mark as burned
    return new_grid

fig, ax = plt.subplots()
im = ax.imshow(grid, cmap='hot', interpolation='nearest')

def animate(frame):
    global grid
    grid = update_fire(grid)
    im.set_array(grid)
    return [im]

ani = animation.FuncAnimation(fig, animate, frames=30, interval=300, blit=True)
plt.title("Simulated Fire Spread")
plt.show()

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import classification_report

# Load data
df = pd.read_csv(r"D:\Excel\MODIS_C6_1_Global_24h.csv")

# Drop rows with missing values
df.dropna(inplace=True)

# Extract useful features
features = ['latitude', 'longitude', 'brightness', 'scan', 'track', 'acq_time', 'bright_t31', 'frp']
target = 'fire'  # We'll define this below

# Create binary fire column based on a threshold
df['fire'] = df['confidence'].apply(lambda x: 1 if x > 60 else 0)

# Convert time if needed
df['acq_time'] = df['acq_time'].astype(int)

# Prepare data
X = df[features]
y = df[target]

# Split and train
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Evaluation
y_pred = model.predict(X_test)
print(classification_report(y_test, y_pred))

# Get only predicted fire locations
df_pred = df.copy()
df_pred['pred'] = model.predict(X)

# Filter predicted fire points
fire_points = df_pred[df_pred['pred'] == 1][['latitude', 'longitude']]

# Normalize to grid (50x50)
def to_grid_coords(lat, lon):
    row = int((lat - df['latitude'].min()) / (df['latitude'].max() - df['latitude'].min()) * 49)
    col = int((lon - df['longitude'].min()) / (df['longitude'].max() - df['longitude'].min()) * 49)
    return row, col

grid_fire_coords = [to_grid_coords(lat, lon) for lat, lon in zip(fire_points['latitude'], fire_points['longitude'])]

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Create a 50x50 forest grid (0=safe, 1=burning, 2=burned)
grid_size = 50
grid = np.zeros((grid_size, grid_size))

# Set initial fire points
for r, c in grid_fire_coords:
    if 0 <= r < grid_size and 0 <= c < grid_size:
        grid[r, c] = 1  # 1 = burning

# Fire spread function
def spread_fire(grid, wind_dir='E'):
    new_grid = grid.copy()
    rows, cols = grid.shape
    for r in range(rows):
        for c in range(cols):
            if grid[r, c] == 1:  # currently burning
                new_grid[r, c] = 2  # now burned

                # Spread to neighbors (add wind bias)
                neighbors = [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]  # N, S, W, E
                if wind_dir == 'E':  # wind from west → east
                    neighbors.append((r, c+2))  # boost rightward

                for nr, nc in neighbors:
                    if 0 <= nr < rows and 0 <= nc < cols:
                        if grid[nr, nc] == 0:
                            new_grid[nr, nc] = 1  # ignite neighbor
    return new_grid

fig, ax = plt.subplots()
ims = []
timesteps = 30  # total time frames

for t in range(timesteps):
    im = ax.imshow(grid, animated=True, cmap='hot', vmin=0, vmax=2)
    text = ax.text(0.5, 1.05, f"Timestep: {t}", size=12, ha="center", transform=ax.transAxes)
    ims.append([im, text])
    grid = spread_fire(grid, wind_dir='E')  # update grid

ani = animation.ArtistAnimation(fig, ims, interval=500, repeat_delay=1000)
plt.show()

ani.save('fire_spread.gif', writer='pillow')

import numpy as np
import matplotlib.pyplot as plt

grid_size = 50
grid = np.zeros((grid_size, grid_size))

# Dummy fire coordinates for now (you can replace this with model predicted coords)
# These are just test fires so animation works.
grid_fire_coords = [(10, 10), (25, 30), (40, 20)]

# Add fire points
for r, c in grid_fire_coords:
    if 0 <= r < grid_size and 0 <= c < grid_size:
        grid[r, c] = 1

# ✅ Check if fire points are added
print("Fire Points in Grid:\n", np.argwhere(grid == 1))

# Optional: plot static fire start state
plt.imshow(grid, cmap='hot', vmin=0, vmax=2)
plt.title("Initial Grid")
plt.colorbar()
plt.show()

import matplotlib.pyplot as plt
import matplotlib.animation as animation

fig, ax = plt.subplots()
ims = []

timesteps = 30
for t in range(timesteps):
    im = ax.imshow(grid.copy(), animated=True, cmap='hot', vmin=0, vmax=2)
    title = ax.text(0.5, -0.1, f"Timestep: {t}", size=12, ha="center", transform=ax.transAxes)
    ims.append([im, title])
    grid = spread_fire(grid, wind_dir='E')

ani = animation.ArtistAnimation(fig, ims, interval=500, repeat_delay=1000)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation

# Fire spreading function
def spread_fire(grid, wind_dir='E'):
    new_grid = grid.copy()
    for r in range(1, grid.shape[0] - 1):
        for c in range(1, grid.shape[1] - 1):
            if grid[r, c] == 1:  # If current cell is fire
                new_grid[r, c] = 2  # Burnt
                if wind_dir == 'E':
                    new_grid[r, c+1] = 1
                elif wind_dir == 'W':
                    new_grid[r, c-1] = 1
                elif wind_dir == 'N':
                    new_grid[r-1, c] = 1
                elif wind_dir == 'S':
                    new_grid[r+1, c] = 1
    return new_grid

# Initialize Grid
grid_size = 50
grid = np.zeros((grid_size, grid_size))

# Add model-predicted fire points (dummy for now)
fire_coords = [(0, 0), (30, 2), (0, 47), (47, 0)]  # You can replace these with your model output
for r, c in fire_coords:
    grid[r, c] = 1

# Set up plot
fig, ax = plt.subplots()
im = ax.imshow(grid, cmap='hot', vmin=0, vmax=2)
title = ax.set_title("Timestep: 0")

def update(t):
    global grid
    grid = spread_fire(grid, wind_dir='E')
    im.set_array(grid)
    title.set_text(f"Timestep: {t}")
    return [im, title]

ani = animation.FuncAnimation(fig, update, frames=30, interval=300, blit=True)
plt.show()

!pip install ipywidgets

!jupyter nbextension enable --py widgetsnbextension

ani.save("fire_spread.gif", writer='pillow')
# or MP4
# ani.save("fire_spread.mp4", writer='ffmpeg')

from IPython.display import HTML
HTML(ani.to_jshtml())

import numpy as np

def spread_fire(grid):
    rows, cols = grid.shape
    new_grid = grid.copy()

    for i in range(rows):
        for j in range(cols):
            if grid[i, j] == 1:  # Fire cell
                # Spread to 8 neighboring cells
                for dx in [-1, 0, 1]:
                    for dy in [-1, 0, 1]:
                        ni, nj = i + dx, j + dy
                        if (dx != 0 or dy != 0) and 0 <= ni < rows and 0 <= nj < cols:
                            if grid[ni, nj] == 0:
                                new_grid[ni, nj] = 1
    return new_grid

frames = []
grid = initial_fire_grid.copy()

for t in range(total_timesteps):
    grid = spread_fire(grid)
    frames.append(grid.copy())



